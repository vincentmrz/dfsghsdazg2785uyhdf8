<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Suivi Muscu – Programme Coach Ultime</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#020617" />
  <meta name="color-scheme" content="dark" />

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">

  <style>
  :root{
    --bg-page:#020617;
    --bg-app:#070d1a;
    --bg-card:#0b1220;
    --bg-card-hi:#0e1830;
    --bg-section:#050a14;
    --bg-input:#020617;

    --accent:#fb4b5a;
    --accent-strong:#f97316;
    --accent-blue:#38bdf8;

    --text:#f9fafb;
    --muted:#e5e7eb;
    --muted-soft:#cbd5f5;

    --danger:#fb7185;

    --border-subtle:rgba(148,163,184,0.45);
    --border:rgba(75,85,99,1);
    --border-soft:rgba(51,65,85,0.88);
    --border-strong:rgba(248,113,113,0.95);

    --shadow-soft:0 18px 46px rgba(0,0,0,0.45);
    --shadow-card:0 14px 30px rgba(0,0,0,0.32);

    --radius-xl:26px;
    --radius-lg:22px;
    --radius-md:14px;
    --radius-pill:999px;

    --fs-base:20px;
    --fs-card-title:1.35rem;
    --fs-section-title:1.08rem;
    --fs-label:1.08rem;

    --safe-top:env(safe-area-inset-top,0px);
    --safe-right:env(safe-area-inset-right,0px);
    --safe-bottom:env(safe-area-inset-bottom,0px);
    --safe-left:env(safe-area-inset-left,0px);
  }

  *{
    box-sizing:border-box;margin:0;padding:0;
    font-family:"Plus Jakarta Sans",system-ui,-apple-system,BlinkMacSystemFont,"SF Pro Text",sans-serif;
    -webkit-tap-highlight-color:transparent;
  }

  :focus-visible{
    outline:3px solid rgba(56,189,248,0.65);
    outline-offset:2px;
    border-radius:14px;
  }

  body{
    background:radial-gradient(circle at top,#1f2937 0,#020617 45%,#000 100%);
    color:var(--text);
    min-height:100vh;
    display:flex;
    justify-content:center;
    padding:calc(2px + var(--safe-top)) calc(0px + var(--safe-right)) calc(2px + var(--safe-bottom)) calc(0px + var(--safe-left));
    font-size:var(--fs-base);
    line-height:1.65;
  }

  .app{
    width:100%;
    max-width:600px;
    border-radius:var(--radius-xl);
    padding:2px;
    background:linear-gradient(135deg,var(--accent),var(--accent-strong));
    box-shadow:var(--shadow-soft);
    overflow:hidden;
  }

  .app-inner{
    border-radius:calc(var(--radius-xl) - 3px);
    background:linear-gradient(180deg,var(--bg-app) 0%,#020617 70%,#020617 100%);
    border:1px solid #020617;
    padding:10px 0 22px;
  }

  main{
    display:flex;
    flex-direction:column;
    gap:18px;
    padding:0;
  }

  section.card{
    background:linear-gradient(180deg,rgba(11,18,32,0.98),rgba(5,10,20,0.98));
    border-radius:var(--radius-lg);
    padding:18px 12px;
    border:1px solid var(--border-soft);
    box-shadow:var(--shadow-card);
  }

  .card-header{
    display:flex;
    justify-content:space-between;
    align-items:flex-start;
    gap:10px;
    margin-bottom:14px;
  }

  .card-title-group{
    display:flex;
    flex-direction:column;
    gap:4px;
    min-width:0;
  }

  .card-title{
    font-size:var(--fs-card-title);
    font-weight:900;
    color:#f9fafb;
    letter-spacing:0.18em;
    text-transform:uppercase;
  }

  .card-subtitle{
    font-size:1.02rem;
    color:var(--muted-soft);
  }

.header-actions{
  display:flex;
  flex-direction:row;       /* ✅ icône à droite */
  align-items:center;       /* ✅ bien aligné verticalement */
  gap:10px;
  flex:0 0 auto;
}


  .card-tag{
    display:inline-flex;
    align-items:center;
    gap:6px;
    font-size:0.94rem;
    padding:7px 13px;
    border-radius:var(--radius-pill);
    border:1px solid var(--border);
    background:rgba(2,6,23,0.85);
    color:var(--muted-soft);
    white-space:nowrap;
    font-weight:800;
    letter-spacing:0.04em;
  }

  .card-tag span#day-chip{
    padding:4px 12px;
    border-radius:var(--radius-pill);
    background:linear-gradient(135deg,var(--accent),var(--accent-strong));
    color:#111827;
    font-weight:1000;
    letter-spacing:0.1em;
    text-transform:uppercase;
  }

  .icon-btn{
    width:46px;
    height:46px;
    border-radius:999px;
    border:1px solid rgba(148,163,184,0.45);
    background:rgba(2,6,23,0.82);
    box-shadow:inset 0 0 0 1px rgba(255,255,255,0.06), 0 14px 28px rgba(0,0,0,0.22);
    display:inline-flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    touch-action:manipulation;
  }
  .icon-btn svg{ width:22px; height:22px; opacity:0.92; }
  .icon-btn:active{ transform:scale(0.98); }
  .icon-btn:focus{ border-color:rgba(56,189,248,0.65); box-shadow:0 0 0 3px rgba(56,189,248,0.22); }

  .card-body{ display:flex; flex-direction:column; gap:12px; }

  .card-section{
    padding:14px 13px 16px;
    border-radius:var(--radius-md);
    background:rgba(2,6,23,0.75);
    border:1px solid rgba(51,65,85,0.75);
  }

  .section-header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    margin-bottom:10px;
    gap:12px;
    padding-bottom:8px;
    border-bottom:1px solid rgba(55,65,81,0.75);
  }

  .section-title{
    font-size:var(--fs-section-title);
    text-transform:uppercase;
    letter-spacing:0.22em;
    color:var(--muted-soft);
    font-weight:1000;
  }
  .section-title span{ color:var(--accent); margin-right:6px; font-weight:1000; }

  .section-note{ font-size:0.98rem; color:var(--muted-soft); text-align:right; }

  .stack{ display:flex; flex-direction:column; gap:10px; }

  label{
    font-size:var(--fs-label);
    color:#e5e7eb;
    margin-bottom:5px;
    display:block;
    font-weight:1000;
    text-transform:uppercase;
    letter-spacing:0.11em;
  }

  /* CHAMPS – version VIF (fond clair + texte noir) */
  select,
  input{
    width:100%;
    padding:13px 15px;
    border-radius:13px;

    background:linear-gradient(180deg,#fff7ed 0%, #ffe4e6 55%, #ffd8b5 100%);
    color:#0b1220;
    font-size:1.06rem;
    font-weight:900;

    border:1px solid rgba(251,75,90,0.85);
    box-shadow:
      0 10px 24px rgba(0,0,0,0.28),
      inset 0 0 0 1px rgba(255,255,255,0.65);
    outline:none;
  }

  input::placeholder{
    color:rgba(11,18,32,0.55);
    font-weight:800;
  }

  select{
    appearance:none;
    -webkit-appearance:none;
    background-image:
      linear-gradient(45deg,transparent 50%, rgba(11,18,32,0.75) 50%),
      linear-gradient(135deg,rgba(11,18,32,0.75) 50%, transparent 50%),
      linear-gradient(180deg,#fff7ed 0%, #ffe4e6 55%, #ffd8b5 100%);
    background-position:
      calc(100% - 18px) 52%,
      calc(100% - 12px) 52%,
      0 0;
    background-size:7px 7px, 7px 7px, 100% 100%;
    background-repeat:no-repeat;
    cursor:pointer;
  }

  select:focus,
  input:focus{
    border-color:rgba(56,189,248,0.95);
    box-shadow:
      0 0 0 3px rgba(56,189,248,0.30),
      0 12px 28px rgba(0,0,0,0.30),
      inset 0 0 0 1px rgba(255,255,255,0.70);
  }

  .row{ display:flex; gap:12px; }
  .row > div{ flex:1; }

  .hint{
    margin-top:8px;
    padding:10px 12px;
    border-radius:14px;
    border:1px dashed rgba(148,163,184,0.35);
    color:var(--muted-soft);
    background:rgba(2,6,23,0.65);
    font-size:0.95rem;
  }
  .hint strong{ color:#f9fafb; font-weight:1000; }

  .info-grid{
    display:grid;
    grid-template-columns:repeat(2,minmax(0,1fr));
    gap:12px;
    margin-top:12px;
  }

  .info-box{
    padding:12px 13px;
    border-radius:14px;
    background:rgba(2,6,23,0.92);
    border:1px solid rgba(55,65,81,0.85);
    display:flex;
    flex-direction:column;
    gap:6px;
  }

  .info-label{
    text-transform:uppercase;
    letter-spacing:0.12em;
    font-size:0.9rem;
    color:#fecaca;
    margin-bottom:2px;
    font-weight:1000;
  }

  .info-value{
    color:#e5e7eb;
    font-weight:1000;
    line-height:1.35;
  }

  .target-line{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:4px 0;
  }
  .target-line + .target-line{
    border-top:1px dashed rgba(55,65,81,0.85);
    margin-top:5px;
    padding-top:7px;
  }
  .target-label{
    font-size:0.84rem;
    text-transform:uppercase;
    letter-spacing:0.12em;
    color:#9ca3af;
    font-weight:1000;
  }
  .target-value{
    font-weight:1100;
    letter-spacing:0.02em;
    color:#f9fafb;
  }

  .info-span-full{
    grid-column:1 / -1;
    padding-top:10px;
    border-top:1px dashed rgba(55,65,81,0.75);
    margin-top:2px;
  }

  .mini-lines{ display:flex; flex-direction:column; gap:6px; }
  .mini-line{ display:flex; justify-content:space-between; gap:10px; }
  .mini-k{ color:rgba(203,213,245,0.92); font-weight:1000; letter-spacing:0.08em; text-transform:uppercase; font-size:0.88rem; }
  .mini-v{ color:#f9fafb; font-weight:1200; }

  .btn{
    width:100%;
    border-radius:var(--radius-pill);
    border:none;
    padding:14px 22px;
    font-size:1.08rem;
    font-weight:900;
    font-synthesis:weight;
    letter-spacing:0.10em;
    text-transform:uppercase;
    cursor:pointer;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    gap:8px;
    touch-action:manipulation;
    user-select:none;
  }

  .btn-inline{ width:auto; padding:10px 12px; }

  .btn-primary{
    background:linear-gradient(135deg, var(--accent), var(--accent-strong));
    color:#06101f;
    border:1px solid var(--border-strong);
    box-shadow:0 12px 28px rgba(248,113,113,0.45);
    font-weight:950;
    letter-spacing:0.06em;
    -webkit-text-stroke:0.45px rgba(0,0,0,0.28);
    text-shadow:0 1px 0 rgba(255,255,255,0.20);
  }

  .btn-outline{
    background:rgba(2,6,23,0.9);
    color:var(--muted);
    border:1px solid var(--border);
  }

  .btn-sm{ padding:10px 13px; font-size:0.88rem; letter-spacing:0.1em; }

  .btn-danger{
    background:rgba(127,29,29,0.18);
    color:#fecaca;
    border:1px solid rgba(248,113,113,0.9);
  }
  .btn-danger-active{
    border-color:var(--danger)!important;
    color:#fecaca!important;
    background:rgba(239,68,68,0.18)!important;
  }

  .quick-grid{
    display:grid;
    grid-template-columns:repeat(4, minmax(0, 1fr));
    gap:8px;
    margin-top:10px;
  }
  .qbtn{
    border-radius:999px;
    border:1px solid rgba(251,75,90,0.55);
    background:rgba(255,247,237,0.92);
    color:#0b1220;
    padding:10px 8px;
    font-weight:1000;
    letter-spacing:0.06em;
    text-transform:uppercase;
    font-size:0.82rem;
    cursor:pointer;
    touch-action:manipulation;
  }
  .qbtn.alt{
    border-color:rgba(56,189,248,0.55);
    background:rgba(219,234,254,0.88);
  }

  .warmup-card{
    font-size:1.12rem;
    color:var(--muted);
    padding:14px 13px;
    border-radius:14px;
    background:rgba(2,6,23,0.88);
    border:1px dashed rgba(55,65,81,0.92);
    line-height:1.75;
  }
  .warmup-card strong{
    color:#f9fafb;
    font-weight:1200;
  }

  #edit-indicator{
    font-size:0.95rem;
    color:var(--muted-soft);
    margin-top:6px;
    text-align:center;
    font-weight:900;
    letter-spacing:0.03em;
  }

  .log-list{
    max-height:min(44vh,340px);
    overflow-y:auto;
    padding-right:4px;
    margin-top:6px;
    overscroll-behavior:contain;
  }

  .log-item{
    padding:10px 11px;
    border-radius:14px;
    border:1px solid rgba(51,65,85,0.8);
    background:rgba(2,6,23,0.9);
    margin-bottom:8px;
    display:flex;
    justify-content:space-between;
    align-items:flex-start;
    gap:10px;
  }

  .log-main{ display:flex; flex-direction:column; gap:6px; min-width:0; }

  .log-title{
    font-size:1.04rem;
    color:#f9fafb;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
    font-weight:1000;
  }

  .log-meta{ font-size:0.96rem; color:var(--muted-soft); font-weight:800; }

  .log-actions{ display:flex; flex-direction:column; align-items:flex-end; gap:8px; flex:0 0 auto; }

  .log-tag{
    font-size:0.95rem;
    color:var(--accent);
    font-variant-numeric:tabular-nums;
    white-space:nowrap;
    font-weight:1200;
    letter-spacing:0.06em;
  }

  .log-btns{ display:flex; gap:8px; }

  .log-edit-btn, .log-delete-btn{
    border-radius:var(--radius-pill);
    font-size:0.86rem;
    padding:6px 10px;
    cursor:pointer;
    border:1px solid var(--border);
    background:rgba(2,6,23,0.95);
    color:var(--muted-soft);
    font-weight:1000;
    letter-spacing:0.06em;
    text-transform:uppercase;
    touch-action:manipulation;
  }

  .log-delete-btn{
    border-color:rgba(248,113,113,0.85);
    background:rgba(127,29,29,0.14);
    color:#fecaca;
  }

  .log-delete-btn.confirm{
    border-color:rgba(248,113,113,1);
    background:rgba(239,68,68,0.22);
    color:#fff;
  }

  .progress-chart-wrapper{
    margin-top:8px;
    border-radius:14px;
    background:rgba(2,6,23,0.88);
    border:1px solid rgba(51,65,85,0.85);
    padding:12px 10px 10px;
  }

  .progress-chart-placeholder{
    font-size:0.98rem;
    color:var(--muted-soft);
    text-align:center;
    padding:12px 4px 8px;
    font-weight:800;
  }

  /* ✅ Graphique plus grand */
  #progress-chart svg{ width:100%; height:210px; display:block; }

  .toast{
    position:fixed;
    left:50%;
    transform:translateX(-50%);
    bottom:calc(12px + var(--safe-bottom));
    z-index:60;

    max-width:min(560px, calc(100vw - 18px));
    width:max-content;

    padding:10px 12px;
    border-radius:16px;
    background:rgba(2,6,23,0.94);
    border:1px solid rgba(148,163,184,0.35);
    box-shadow:0 14px 36px rgba(0,0,0,0.35);

    display:none;
    align-items:center;
    gap:10px;
  }
  .toast.show{ display:inline-flex; }

  .toast-msg{
    color:var(--text);
    font-size:0.95rem;
    font-weight:1000;
    letter-spacing:0.06em;
    text-transform:uppercase;
    line-height:1.3;
  }

  .toast-action{
    border-radius:var(--radius-pill);
    border:1px solid rgba(56,189,248,0.6);
    background:rgba(56,189,248,0.12);
    color:#dbeafe;
    font-size:0.88rem;
    padding:7px 10px;
    font-weight:1100;
    letter-spacing:0.08em;
    text-transform:uppercase;
    cursor:pointer;
    touch-action:manipulation;
  }

  .modal{
    position:fixed;
    inset:0;
    z-index:80;
    background:rgba(0,0,0,0.55);
    display:none;
    align-items:center;
    justify-content:center;
    padding:calc(14px + var(--safe-top)) calc(14px + var(--safe-right)) calc(14px + var(--safe-bottom)) calc(14px + var(--safe-left));
  }
  .modal.show{ display:flex; }

  .modal-card{
    width:min(560px, 100%);
    border-radius:22px;
    border:1px solid rgba(148,163,184,0.35);
    background:linear-gradient(180deg, rgba(11,18,32,0.98), rgba(2,6,23,0.98));
    box-shadow:0 30px 80px rgba(0,0,0,0.55);
    padding:16px;
  }

  .modal-title{
    font-weight:1200;
    letter-spacing:0.12em;
    text-transform:uppercase;
    font-size:1.05rem;
    color:#f9fafb;
    margin-bottom:10px;
  }

  .modal-body{
    color:var(--muted-soft);
    font-size:1rem;
    font-weight:800;
    line-height:1.55;
  }

  .modal-actions{ display:flex; gap:10px; margin-top:14px; }
  .modal-actions .btn{ flex:1; }

  /* Contrôle date historique */
  .history-controls{
    display:flex;
    align-items:center;
    gap:10px;
    flex-wrap:wrap;
    justify-content:flex-end;
  }
  .date-input{
    width:auto !important;
    max-width:180px;
    padding:10px 12px !important;
    font-size:0.92rem !important;
    letter-spacing:0.06em;
    text-transform:uppercase;
  }

  /* RÉGLAGES (dans modal) */
  .settings-grid{
    display:grid;
    grid-template-columns:repeat(2, minmax(0,1fr));
    gap:10px;
    margin-top:10px;
  }
  .setting-row{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    padding:12px 12px;
    border-radius:14px;
    border:1px solid rgba(51,65,85,0.78);
    background:rgba(2,6,23,0.82);
  }
  .setting-left{ display:flex; flex-direction:column; gap:2px; min-width:0; }
  .setting-name{
    font-weight:1200;
    letter-spacing:0.12em;
    text-transform:uppercase;
    font-size:0.92rem;
    color:#f9fafb;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .setting-desc{
    font-size:0.92rem;
    color:rgba(203,213,245,0.92);
    font-weight:800;
  }

  /* Toggle (override input global) */
  input.toggle{
    width:58px !important;
    min-width:58px !important;
    height:34px !important;
    padding:0 !important;
    border-radius:999px !important;
    border:1px solid rgba(148,163,184,0.45) !important;
    background:rgba(2,6,23,0.92) !important;
    box-shadow:inset 0 0 0 1px rgba(255,255,255,0.08) !important;
    appearance:none !important;
    -webkit-appearance:none !important;
    cursor:pointer;
    position:relative;
  }
  input.toggle::before{
    content:"";
    position:absolute;
    top:4px;
    left:4px;
    width:26px;
    height:26px;
    border-radius:999px;
    background:linear-gradient(180deg,#fff7ed,#ffe4e6);
    border:1px solid rgba(0,0,0,0.18);
  }
  input.toggle:checked{
    border-color:rgba(56,189,248,0.55) !important;
    background:linear-gradient(135deg, rgba(56,189,248,0.25), rgba(251,75,90,0.25)) !important;
  }
  input.toggle:checked::before{
    left:calc(100% - 30px);
    background:linear-gradient(135deg,#dbeafe,#fff7ed);
  }

  /* ✅ Timer overlay plein écran */
  .timer-overlay{
    position:fixed;
    inset:0;
    z-index:120;
    display:none;
    align-items:center;
    justify-content:center;
    padding:calc(14px + var(--safe-top)) calc(14px + var(--safe-right)) calc(14px + var(--safe-bottom)) calc(14px + var(--safe-left));
    background:radial-gradient(circle at top, rgba(31,41,55,0.85) 0, rgba(2,6,23,0.92) 55%, rgba(0,0,0,0.92) 100%);
    backdrop-filter:blur(6px);
  }
  .timer-overlay.show{ display:flex; }

  .timer-overlay-card{
    width:min(560px, 100%);
    border-radius:26px;
    border:1px solid rgba(148,163,184,0.35);
    background:linear-gradient(180deg, rgba(11,18,32,0.98), rgba(2,6,23,0.98));
    box-shadow:0 30px 90px rgba(0,0,0,0.60);
    padding:16px;
  }
  .timer-top{
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap:10px;
    margin-bottom:12px;
  }
  .timer-title{
    font-weight:1000;
    text-transform:uppercase;
    letter-spacing:0.16em;
    font-size:1.05rem;
    color:#f9fafb;
  }
  .timer-sub{
    margin-top:4px;
    color:rgba(203,213,245,0.90);
    font-weight:800;
    font-size:0.98rem;
  }
  .timer-x{
    width:44px;height:44px;
    border-radius:999px;
    border:1px solid rgba(148,163,184,0.40);
    background:rgba(2,6,23,0.75);
    color:#e5e7eb;
    font-weight:1100;
    cursor:pointer;
  }
  .timer-x:active{ transform:scale(0.98); }

  .timer-display{
    font-variant-numeric:tabular-nums;
    font-size:3.3rem;
    font-weight:1200;
    letter-spacing:0.18em;
    text-align:center;
    padding:14px 18px;
    border-radius:var(--radius-pill);
    background:rgba(2,6,23,0.95);
    border:1px solid var(--border-strong);
    margin:10px 0 6px;
  }
  .timer-label{
    text-align:center;
    font-size:1.06rem;
    color:var(--muted-soft);
    font-weight:900;
    letter-spacing:0.04em;
  }

  .timer-controls{
    display:flex;
    gap:10px;
    width:100%;
    margin-top:14px;
  }
  .timer-controls .btn{ flex:1; }

  @media (max-width:480px){
    body{ font-size:19px; }
    .card-title{ font-size:1.18rem; }
    section.card{ padding:18px 12px; }
    .app-inner{ padding:8px 0 20px; }
    .quick-grid{ grid-template-columns:repeat(2,minmax(0,1fr)); }
    .settings-grid{ grid-template-columns:1fr; }
    #progress-chart svg{ height:230px; } /* encore + grand sur tel */
    .timer-display{ font-size:3.0rem; }
  }
  </style>
</head>

<body>
  <div class="app" role="application" aria-label="Suivi musculation">
    <div class="app-inner">
      <main>
        <!-- SÉANCE & SÉRIE -->
        <section class="card">
          <div class="card-header">
            <div class="card-title-group">
              <div class="card-title">Séance & exercice</div>
              <div class="card-subtitle" id="today-label"></div>
            </div>

            <!-- ✅ Jour + icône réglages sous "Jour/VEN" -->
            <div class="header-actions">
              <div class="card-tag">
                Jour <span id="day-chip">–</span>
              </div>

              <button id="settings-btn" class="icon-btn" type="button" aria-label="Réglages">
                <!-- sliders icon -->
                <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                  <path d="M4 6h9" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                  <path d="M17 6h3" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                  <path d="M13 6v0" stroke="currentColor" stroke-width="6" stroke-linecap="round"/>
                  <path d="M4 12h3" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                  <path d="M11 12h9" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                  <path d="M7 12v0" stroke="currentColor" stroke-width="6" stroke-linecap="round"/>
                  <path d="M4 18h11" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                  <path d="M19 18h1" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                  <path d="M15 18v0" stroke="currentColor" stroke-width="6" stroke-linecap="round"/>
                </svg>
              </button>
            </div>
          </div>

          <div class="card-body">
            <div class="card-section">
              <div class="section-header">
                <div class="section-title"><span>1.</span> Sélection</div>
                <div class="section-note">Choisis ta séance puis l'exercice</div>
              </div>

              <div class="stack">
                <div>
                  <label for="workout-select">Séance</label>
                  <select id="workout-select" aria-label="Séance"></select>
                </div>

                <div>
                  <label for="exercise-select">Exercice</label>
                  <select id="exercise-select" aria-label="Exercice"></select>
                </div>

                <div class="info-grid" aria-label="Informations exercice">
                  <div class="info-box">
                    <div class="info-label">Repos</div>
                    <div class="info-value" id="exercise-rest-label">–</div>
                  </div>

                  <div class="info-box">
                    <div class="info-label">Cible</div>
                    <div class="info-value" id="exercise-target-info">–</div>
                  </div>

                  <div class="info-span-full">
                    <div class="info-label">Progression aujourd’hui</div>
                    <div class="info-value" id="exercise-sets-info">Séries terminées aujourd’hui : 0 / 0</div>
                  </div>

                  <div class="info-span-full">
                    <div class="info-label">Dernière perf</div>
                    <div class="info-value" id="exercise-last-info">–</div>
                  </div>
                </div>

                <div class="hint" id="autofill-hint" style="display:none;">
                  <strong>Astuce :</strong> j’ai pré-rempli poids/reps depuis ta dernière perf.
                </div>
              </div>
            </div>

            <div class="card-section">
              <div class="section-header">
                <div class="section-title"><span>2.</span> Série & repos</div>
                <div class="section-note">Valide la série puis récupère</div>
              </div>

              <div class="row" style="margin-bottom:10px;">
                <div>
                  <label for="weight-input">Poids (kg)</label>
                  <input id="weight-input" type="number" min="0" step="0.5" inputmode="decimal" placeholder="ex: 80" autocomplete="off" />
                </div>
                <div>
                  <label for="reps-input">Reps</label>
                  <input id="reps-input" type="number" min="1" step="1" inputmode="numeric" placeholder="ex: 8" autocomplete="off" />
                </div>
              </div>

              <div class="quick-grid" aria-label="Raccourcis">
                <button class="qbtn alt" type="button" data-q="w:-2.5">-2.5 KG</button>
                <button class="qbtn alt" type="button" data-q="w:+2.5">+2.5 KG</button>
                <button class="qbtn alt" type="button" data-q="w:+5">+5 KG</button>
                <button class="qbtn" type="button" data-q="w:clear">RESET KG</button>

                <button class="qbtn alt" type="button" data-q="r:-1">-1 REP</button>
                <button class="qbtn alt" type="button" data-q="r:+1">+1 REP</button>
                <button class="qbtn alt" type="button" data-q="r:+2">+2 REPS</button>
                <button class="qbtn" type="button" data-q="r:clear">RESET REPS</button>
              </div>

              <button id="log-set-btn" class="btn btn-primary" type="button" style="margin-top:12px;">
                Valider la série & lancer le repos
              </button>

              <button id="cancel-edit-btn" class="btn btn-outline btn-sm" type="button" style="margin-top:8px; display:none;">
                Annuler la modification
              </button>

              <div id="edit-indicator" style="display:none;">
                Mode édition : tu modifies une série de l'historique.
              </div>
            </div>

            <div class="card-section">
              <div class="section-header">
                <div class="section-title"><span>3.</span> Échauffement & cardio</div>
              </div>
              <div class="warmup-card" id="warmup-card">
                <p><strong>Échauffement :</strong> –</p>
                <p><strong>Cardio fin de séance :</strong> –</p>
              </div>
            </div>
          </div>
        </section>

        <!-- HISTORIQUE -->
        <section class="card">
          <div class="card-header">
            <div class="card-title-group">
              <div class="card-title">Historique</div>
              <div class="card-subtitle" id="history-summary">Séries enregistrées (stockées sur ce téléphone)</div>
            </div>

            <div class="history-controls" aria-label="Choix du jour">
              <input id="history-date" class="date-input" type="date" aria-label="Choisir une date" />
              <button id="history-today-btn" class="btn btn-outline btn-sm btn-inline" type="button">Aujourd’hui</button>
            </div>
          </div>

          <div class="card-body">
            <div class="log-list" id="log-list" aria-label="Historique des séries"></div>

            <button id="clear-history-btn" class="btn btn-outline btn-sm" type="button" style="margin-top:10px;">
              Supprimer tout l'historique
            </button>
          </div>
        </section>

        <!-- PROGRESSION -->
        <section class="card">
          <div class="card-header">
            <div class="card-title-group">
              <div class="card-title">Progression</div>
              <div class="card-subtitle" id="progress-summary">Sélectionne un exercice pour voir l'évolution.</div>
            </div>
          </div>

          <div class="card-body">
            <div class="progress-chart-wrapper">
              <div id="progress-chart" class="progress-chart-placeholder">
                Pas encore de données pour cet exercice.
              </div>
            </div>
          </div>
        </section>
      </main>
    </div>
  </div>

  <!-- ✅ Timer overlay plein écran -->
  <div id="timer-overlay" class="timer-overlay" aria-hidden="true">
    <div class="timer-overlay-card" role="dialog" aria-modal="true" aria-labelledby="timer-title" aria-describedby="timer-sub">
      <div class="timer-top">
        <div>
          <div id="timer-title" class="timer-title">Repos</div>
          <div id="timer-sub" class="timer-sub">Chrono en cours</div>
        </div>
        <button id="timer-close" class="timer-x" type="button" aria-label="Fermer">✕</button>
      </div>

      <div class="timer-display" id="timer-display">00:00</div>
      <div class="timer-label" id="timer-label" role="status" aria-live="polite">Prêt à démarrer</div>

      <div class="timer-controls">
        <button id="pause-timer-btn" class="btn btn-outline btn-sm" type="button">Pause</button>
        <button id="restart-timer-btn" class="btn btn-outline btn-sm" type="button">Relancer</button>
        <button id="reset-timer-btn" class="btn btn-outline btn-sm" type="button">Reset</button>
      </div>
    </div>
  </div>

  <!-- Toast + action (Undo) -->
  <div id="toast" class="toast" aria-live="polite" aria-atomic="true">
    <div id="toast-msg" class="toast-msg"></div>
    <button id="toast-action" class="toast-action" type="button" style="display:none;"></button>
  </div>

  <!-- Modal confirmations -->
  <div id="modal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="modal-title" aria-describedby="modal-body">
      <div id="modal-title" class="modal-title">Confirmer</div>
      <div id="modal-body" class="modal-body"></div>
      <div class="modal-actions">
        <button id="modal-cancel" class="btn btn-outline btn-sm" type="button">Annuler</button>
        <button id="modal-confirm" class="btn btn-danger btn-sm" type="button">Supprimer</button>
      </div>
    </div>
  </div>

  <!-- ✅ Modal Réglages (ouvert via l’icône en haut à droite) -->
  <div id="settings-modal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="settings-title">
      <div class="modal-title" id="settings-title">Réglages</div>
      <div class="modal-body">Active / désactive ce que tu veux.</div>

      <div class="settings-grid">
        <div class="setting-row">
          <div class="setting-left">
            <div class="setting-name">Vibration</div>
            <div class="setting-desc">feedback quand tu valides / finis</div>
          </div>
          <input id="set-vibrate" class="toggle" type="checkbox" aria-label="Activer vibration" />
        </div>

        <div class="setting-row">
          <div class="setting-left">
            <div class="setting-name">Son</div>
            <div class="setting-desc">bip à 10s + fin du repos</div>
          </div>
          <input id="set-sound" class="toggle" type="checkbox" aria-label="Activer son" />
        </div>

        <div class="setting-row">
          <div class="setting-left">
            <div class="setting-name">Notifications</div>
            <div class="setting-desc">alerte repos terminé (si autorisé)</div>
          </div>
          <input id="set-notif" class="toggle" type="checkbox" aria-label="Activer notifications" />
        </div>

        <div class="setting-row">
          <div class="setting-left">
            <div class="setting-name">Auto-remplissage</div>
            <div class="setting-desc">reprend poids/reps de la dernière perf</div>
          </div>
          <input id="set-autofill" class="toggle" type="checkbox" aria-label="Activer auto-remplissage" />
        </div>

        <div class="setting-row">
          <div class="setting-left">
            <div class="setting-name">Auto-suivant</div>
            <div class="setting-desc">passe à l’exercice suivant quand fini</div>
          </div>
          <input id="set-autonext" class="toggle" type="checkbox" aria-label="Activer auto-suivant" />
        </div>

        <div class="setting-row">
          <div class="setting-left">
            <div class="setting-name">Écran allumé</div>
            <div class="setting-desc">évite l’écran qui s’éteint au repos</div>
          </div>
          <input id="set-wakelock" class="toggle" type="checkbox" aria-label="Activer écran allumé" />
        </div>
      </div>

      <div class="modal-actions">
        <button id="settings-close" class="btn btn-outline btn-sm" type="button">Fermer</button>
      </div>
    </div>
  </div>

  <script>
  (function () {
    "use strict";

    const DEFAULT_DATA = {
      workouts: [
        {
          id: "lundi-upper-force",
          name: "Lundi – Upper Force",
          short: "Lun",
          warmup: "5–7 min rameur ou vélo léger + 2 séries de chauffe sur le développé couché (charges progressives).",
          cardio: "Pas de cardio programmé (self-défense ce jour).",
          exercises: [
            { id: "bench", name: "Développé couché barre", restSec: 180, sets: 5, repRange: "4 à 6", rir: "RIR 1–2" },
            { id: "pulldown-neutral", name: "Tirage vertical prise neutre poulie", restSec: 180, sets: 5, repRange: "4 à 6", rir: "RIR 1–2" },
            { id: "chest-press", name: "Presse poitrine horizontale convergente", restSec: 150, sets: 4, repRange: "6 à 8", rir: "RIR 1–2" },
            { id: "row-machine", name: "Rowing assis convergent poitrine appuyée", restSec: 150, sets: 4, repRange: "6 à 8", rir: "RIR 1–2" },
            { id: "shoulder-press", name: "Développé épaules machine convergente", restSec: 120, sets: 3, repRange: "6 à 8", rir: "RIR 1–2" },
            { id: "lat-raise-cable", name: "Élévations latérales poulie unilatérale", restSec: 75, sets: 3, repRange: "12 à 15", rir: "RIR 1–3" },
            { id: "pallof", name: "Gainage anti-rotation (Pallof press)", restSec: 45, sets: 3, repRange: "10 à 12", rir: "RIR 2–3" }
          ]
        },
        {
          id: "mardi-lower-force",
          name: "Mardi – Lower Force",
          short: "Mar",
          warmup: "5–7 min vélo + squats au poids du corps + 2 séries de chauffe à la hack squat.",
          cardio: "20 min marche sur tapis incliné ou vélo léger en fin de séance (zone 2, respiration un peu accélérée mais tu peux parler).",
          exercises: [
            { id: "hack-squat", name: "Hack squat (machine)", restSec: 180, sets: 5, repRange: "4 à 6", rir: "RIR 1–2" },
            { id: "rdl-db", name: "Soulevé de terre roumain haltères", restSec: 150, sets: 4, repRange: "6 à 8", rir: "RIR 1–2" },
            { id: "leg-press", name: "Presse à cuisses", restSec: 150, sets: 3, repRange: "6 à 8", rir: "RIR 1–2" },
            { id: "leg-curl", name: "Leg curl assis (machine)", restSec: 120, sets: 3, repRange: "8 à 10", rir: "RIR 1–2" },
            { id: "calf-press", name: "Mollets à la presse à cuisses", restSec: 90, sets: 4, repRange: "8 à 12", rir: "RIR 1–2" },
            { id: "cable-crunch", name: "Crunch à la poulie haute", restSec: 60, sets: 3, repRange: "12 à 15", rir: "RIR 2–3" }
          ]
        },
        {
          id: "mercredi-push-hypertrophy",
          name: "Mercredi – Push Hypertrophie",
          short: "Mer",
          warmup: "5 min cardio léger + mobilité épaules + 2 séries de chauffe à la presse poitrine.",
          cardio: "Optionnel : 10–15 min marche ou vélo très léger en fin de séance.",
          exercises: [
            { id: "chest-press-horiz", name: "Presse poitrine horizontale convergente", restSec: 150, sets: 4, repRange: "8 à 12", rir: "RIR 1–2" },
            { id: "incline-db", name: "Développé couché haltères incliné (20–30°)", restSec: 120, sets: 3, repRange: "8 à 12", rir: "RIR 1–2" },
            { id: "dips", name: "Dips buste penché", restSec: 150, sets: 3, repRange: "8 à 12", rir: "RIR 1–2" },
            { id: "shoulder-press-machine", name: "Développé épaules machine convergente", restSec: 120, sets: 3, repRange: "8 à 12", rir: "RIR 1–2" },
            { id: "lat-raise-cable-high", name: "Élévations latérales poulie unilatérale", restSec: 75, sets: 4, repRange: "12 à 20", rir: "RIR 1–3" },
            { id: "cable-fly", name: "Écartés aux câbles (debout au centre)", restSec: 75, sets: 3, repRange: "12 à 15", rir: "RIR 1–2" },
            { id: "triceps-rope", name: "Extension triceps à la corde poulie", restSec: 60, sets: 3, repRange: "10 à 15", rir: "RIR 1–2" }
          ]
        },
        {
          id: "jeudi-pull-hypertrophy",
          name: "Jeudi – Pull Hypertrophie",
          short: "Jeu",
          warmup: "5 min cardio léger + 2 séries de tirage vertical très léger.",
          cardio: "Pas de cardio programmé (self-défense ce jour).",
          exercises: [
            { id: "pulldown-neutral-hyp", name: "Tirage vertical prise neutre poulie", restSec: 150, sets: 4, repRange: "8 à 12", rir: "RIR 1–2" },
            { id: "row-machine-hyp", name: "Rowing assis convergent poitrine appuyée", restSec: 150, sets: 4, repRange: "8 à 12", rir: "RIR 1–2" },
            { id: "onearm-cable-row", name: "Rowing unilatéral à la poulie (basse)", restSec: 120, sets: 3, repRange: "10 à 12", rir: "RIR 1–2" },
            { id: "rear-delt-cable", name: "Oiseau à la poulie", restSec: 60, sets: 3, repRange: "15 à 20", rir: "RIR 1–3" },
            { id: "curl-ez", name: "Curl barre EZ debout", restSec: 120, sets: 3, repRange: "8 à 12", rir: "RIR 1–2" },
            { id: "curl-cable", name: "Curl à la poulie basse", restSec: 75, sets: 3, repRange: "10 à 15", rir: "RIR 1–2" },
            { id: "face-pull", name: "Face pull corde poulie", restSec: 60, sets: 3, repRange: "15 à 20", rir: "RIR 1–3" }
          ]
        },
        {
          id: "vendredi-legs-shoulders",
          name: "Vendredi – Legs & Shoulders Hypertrophie",
          short: "Ven",
          warmup: "5–7 min cardio léger + squats à vide + 2 séries de chauffe à la presse à cuisses.",
          cardio: "25–30 min marche sur tapis incliné en fin de séance (zone 2, tranquille mais continu).",
          exercises: [
            { id: "leg-press-hyp", name: "Presse à cuisses", restSec: 150, sets: 4, repRange: "8 à 12", rir: "RIR 1–2" },
            { id: "bulgarian-split", name: "Fentes bulgares haltères", restSec: 150, sets: 3, repRange: "10 à 12", rir: "RIR 1–2" },
            { id: "leg-curl-hyp", name: "Leg curl assis (machine)", restSec: 120, sets: 3, repRange: "10 à 15", rir: "RIR 1–2" },
            { id: "hip-thrust", name: "Hip thrust barre sur banc", restSec: 150, sets: 3, repRange: "8 à 12", rir: "RIR 1–2" },
            { id: "calf-seated", name: "Mollets assis (machine)", restSec: 75, sets: 4, repRange: "12 à 15", rir: "RIR 1–2" },
            { id: "shoulder-press-hyp", name: "Développé épaules machine convergente", restSec: 120, sets: 3, repRange: "8 à 12", rir: "RIR 1–2" },
            { id: "lat-raise-partials", name: "Élévations latérales poulie – partiels", restSec: 60, sets: 2, repRange: "10–12 + 5–10 partiels", rir: "RIR 1–3" }
          ]
        }
      ]
    };

    const STORAGE_KEY_LOGS = "coachUltimeGymLogs";
    const STORAGE_KEY_UI   = "coachUltimeGymUI";
    const STORAGE_KEY_SETTINGS = "coachUltimeGymSettings";
    const STORAGE_KEY_TIMER = "coachUltimeGymTimer";

    let appData = DEFAULT_DATA;
    let logs = {};

    const $ = (id) => document.getElementById(id);

    const workoutSelect = $("workout-select");
    const exerciseSelect = $("exercise-select");
    const exerciseRestLabel = $("exercise-rest-label");
    const exerciseTargetInfo = $("exercise-target-info");
    const exerciseSetsInfo = $("exercise-sets-info");
    const exerciseLastInfo = $("exercise-last-info");
    const autofillHint = $("autofill-hint");
    const weightInput = $("weight-input");
    const repsInput = $("reps-input");

    const logList = $("log-list");
    const todayLabel = $("today-label");
    const dayChip = $("day-chip");
    const progressChart = $("progress-chart");
    const progressSummary = $("progress-summary");
    const historySummary = $("history-summary");

    const historyDateInput = $("history-date");
    const historyTodayBtn = $("history-today-btn");

    const clearHistoryBtn = $("clear-history-btn");
    const warmupCard = $("warmup-card");

    const logSetBtn = $("log-set-btn");
    const cancelEditBtn = $("cancel-edit-btn");
    const editIndicator = $("edit-indicator");

    const toastEl = $("toast");
    const toastMsgEl = $("toast-msg");
    const toastActionBtn = $("toast-action");

    const modalEl = $("modal");
    const modalTitleEl = $("modal-title");
    const modalBodyEl = $("modal-body");
    const modalCancelBtn = $("modal-cancel");
    const modalConfirmBtn = $("modal-confirm");

    // Settings modal + icon button
    const settingsBtn = $("settings-btn");
    const settingsModal = $("settings-modal");
    const settingsCloseBtn = $("settings-close");

    const setVibrate = $("set-vibrate");
    const setSound = $("set-sound");
    const setNotif = $("set-notif");
    const setAutofill = $("set-autofill");
    const setAutonext = $("set-autonext");
    const setWakelock = $("set-wakelock");

    // Timer overlay
    const timerOverlay = $("timer-overlay");
    const timerCloseBtn = $("timer-close");
    const timerDisplay = $("timer-display");
    const timerLabel = $("timer-label");
    const pauseTimerBtn = $("pause-timer-btn");
    const restartTimerBtn = $("restart-timer-btn");
    const resetTimerBtn = $("reset-timer-btn");

    let settings = {
      vibrate: true,
      sound: false,
      notifications: false,
      autofill: true,
      autonext: true,
      wakelock: false
    };

    let timerId = null;
    let timerDeadlineMs = 0;
    let timerRemaining = 0;
    let lastTimerRemaining = null;
    let lastRestSec = 0;
    let timerPaused = false;

    let wakeLockSentinel = null;

    let editingEntry = null;
    const defaultBtnText = "Valider la série & lancer le repos";
    const editBtnText = "Mettre à jour la série";

    let clearConfirm = false;
    let clearConfirmTimeout = null;

    let pendingDelete = null;

    let modalOnConfirm = null;
    let lastFocusEl = null;

    let viewDayKey = null;

    let toastTimeoutId = null;

    let audioCtx = null;

    function safeJsonParse(s, fallback) { try { return JSON.parse(s); } catch (_) { return fallback; } }

    function storageSet(key, value) {
      try { localStorage.setItem(key, value); return true; }
      catch (e) { showToast("Stockage plein / bloqué", { duration: 2200 }); return false; }
    }
    function storageGet(key) {
      try { return localStorage.getItem(key); } catch (_) { return null; }
    }

    function saveTimerState(obj) { storageSet(STORAGE_KEY_TIMER, JSON.stringify(obj || null)); }
    function loadTimerState() {
      const s = storageGet(STORAGE_KEY_TIMER);
      return s ? safeJsonParse(s, null) : null;
    }
    function clearTimerState(){ try{ localStorage.removeItem(STORAGE_KEY_TIMER); }catch(_){ } }

    function loadSettings() {
      const s = storageGet(STORAGE_KEY_SETTINGS);
      const obj = s ? safeJsonParse(s, null) : null;
      if (obj && typeof obj === "object") settings = Object.assign({}, settings, obj);
    }
    function saveSettings() { storageSet(STORAGE_KEY_SETTINGS, JSON.stringify(settings)); }

    function loadLogs() {
      const storedLogs = storageGet(STORAGE_KEY_LOGS);
      logs = storedLogs ? safeJsonParse(storedLogs, {}) : {};
      if (!logs || typeof logs !== "object") logs = {};
    }
    function saveLogs() { storageSet(STORAGE_KEY_LOGS, JSON.stringify(logs)); }

    function saveUIState(ui) { storageSet(STORAGE_KEY_UI, JSON.stringify(ui)); }
    function loadUIState() { const s = storageGet(STORAGE_KEY_UI); return s ? safeJsonParse(s, null) : null; }

    function getTodayKey() {
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      return y + "-" + m + "-" + day;
    }

    function formatTime(seconds) {
      const m = Math.floor(seconds / 60);
      const s = seconds % 60;
      return String(m).padStart(2, "0") + ":" + String(s).padStart(2, "0");
    }

    function secondsToText(seconds) {
      const m = Math.floor(seconds / 60);
      const s = seconds % 60;
      if (m > 0 && s > 0) return m + " min " + s + " s";
      if (m > 0) return m + " min";
      return s + " s";
    }

    function formatHHMM(isoTs) {
      if (!isoTs) return "";
      const d = new Date(isoTs);
      const hh = String(d.getHours()).padStart(2, "0");
      const mm = String(d.getMinutes()).padStart(2, "0");
      return hh + ":" + mm;
    }

    function formatDDMM(dayKey) {
      if (!dayKey || typeof dayKey !== "string") return "";
      const p = dayKey.split("-");
      if (p.length !== 3) return dayKey;
      return p[2] + "/" + p[1];
    }

    function vibrate(pattern) {
      if (!settings.vibrate) return;
      try { if (navigator && navigator.vibrate) navigator.vibrate(pattern); } catch (_) {}
    }

    function ensureAudio() {
      if (audioCtx) return true;
      try {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if (!Ctx) return false;
        audioCtx = new Ctx();
        return true;
      } catch (_) { return false; }
    }

    function beep(freq, ms, gain) {
      if (!settings.sound) return;
      if (!ensureAudio()) return;

      try {
        if (audioCtx.state === "suspended") audioCtx.resume().catch(function(){});
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = "sine";
        osc.frequency.value = freq || 880;
        g.gain.value = typeof gain === "number" ? gain : 0.06;
        osc.connect(g);
        g.connect(audioCtx.destination);
        osc.start();

        setTimeout(function () {
          try { osc.stop(); } catch (_) {}
          try { osc.disconnect(); g.disconnect(); } catch (_) {}
        }, ms || 120);
      } catch (_) {}
    }

    function notifyRestFinished() {
      if (!settings.notifications) return;
      if (!("Notification" in window)) return;

      if (Notification.permission === "granted") {
        try { new Notification("Repos terminé ✔", { body: "Tu peux repartir sur la série suivante." }); } catch (_) {}
      }
    }

    function showToast(message, opts) {
      const o = opts || {};
      toastMsgEl.textContent = message || "";
      toastEl.classList.add("show");

      if (toastTimeoutId) { clearTimeout(toastTimeoutId); toastTimeoutId = null; }

      if (o.actionLabel && typeof o.onAction === "function") {
        toastActionBtn.style.display = "inline-flex";
        toastActionBtn.textContent = o.actionLabel;
        toastActionBtn.onclick = function () {
          try { o.onAction(); } finally { hideToast(); }
        };
      } else {
        toastActionBtn.style.display = "none";
        toastActionBtn.textContent = "";
        toastActionBtn.onclick = null;
      }

      const duration = typeof o.duration === "number" ? o.duration : 1700;
      if (duration > 0) toastTimeoutId = setTimeout(hideToast, duration);
    }

    function hideToast() {
      if (toastTimeoutId) { clearTimeout(toastTimeoutId); toastTimeoutId = null; }
      toastEl.classList.remove("show");
      toastActionBtn.style.display = "none";
      toastActionBtn.textContent = "";
      toastActionBtn.onclick = null;
    }

    function openModal(cfg) {
      lastFocusEl = document.activeElement;

      modalTitleEl.textContent = cfg.title || "Confirmer";
      modalBodyEl.textContent = cfg.body || "";
      modalConfirmBtn.textContent = cfg.confirmText || "Confirmer";
      modalCancelBtn.textContent = cfg.cancelText || "Annuler";

      modalOnConfirm = typeof cfg.onConfirm === "function" ? cfg.onConfirm : null;

      modalEl.classList.add("show");
      modalEl.setAttribute("aria-hidden", "false");
      document.body.style.overflow = "hidden";

      setTimeout(function () { modalCancelBtn.focus(); }, 0);
    }

    function closeModal() {
      modalEl.classList.remove("show");
      modalEl.setAttribute("aria-hidden", "true");
      document.body.style.overflow = "";

      const toFocus = lastFocusEl;
      lastFocusEl = null;
      modalOnConfirm = null;

      if (toFocus && typeof toFocus.focus === "function") setTimeout(function () { toFocus.focus(); }, 0);
    }

    modalCancelBtn.addEventListener("click", closeModal);
    modalConfirmBtn.addEventListener("click", function () {
      const fn = modalOnConfirm;
      closeModal();
      if (fn) fn();
    });
    modalEl.addEventListener("click", function (e) { if (e.target === modalEl) closeModal(); });
    document.addEventListener("keydown", function (e) {
      if (modalEl.classList.contains("show") && e.key === "Escape") closeModal();
    });

    function openSettings() {
      settingsModal.classList.add("show");
      settingsModal.setAttribute("aria-hidden", "false");
      document.body.style.overflow = "hidden";
      setTimeout(function(){ settingsCloseBtn.focus(); }, 0);
    }
    function closeSettings() {
      settingsModal.classList.remove("show");
      settingsModal.setAttribute("aria-hidden", "true");
      document.body.style.overflow = "";
    }
    settingsBtn.addEventListener("click", function(){
      openSettings();
      showToast("Réglages", { duration: 900 });
      vibrate([10]);
    });
    settingsCloseBtn.addEventListener("click", closeSettings);
    settingsModal.addEventListener("click", function(e){ if (e.target === settingsModal) closeSettings(); });
    document.addEventListener("keydown", function(e){
      if (settingsModal.classList.contains("show") && e.key === "Escape") closeSettings();
    });

    function getWorkoutById(id) {
      for (let i = 0; i < appData.workouts.length; i++) if (appData.workouts[i].id === id) return appData.workouts[i];
      return null;
    }

    function getExerciseById(workout, exerciseId) {
      if (!workout) return null;
      for (let i = 0; i < workout.exercises.length; i++) if (workout.exercises[i].id === exerciseId) return workout.exercises[i];
      return null;
    }

    function initTodayUI() {
      const d = new Date();
      const days = ["Dimanche","Lundi","Mardi","Mercredi","Jeudi","Vendredi","Samedi"];
      const shortDays = ["Dim","Lun","Mar","Mer","Jeu","Ven","Sam"];
      todayLabel.textContent = days[d.getDay()];
      dayChip.textContent = shortDays[d.getDay()];
    }

    function populateWorkoutSelect(defaultWorkoutId) {
      workoutSelect.innerHTML = "";
      for (let i = 0; i < appData.workouts.length; i++) {
        const w = appData.workouts[i];
        const opt = document.createElement("option");
        opt.value = w.id;
        opt.textContent = w.name;
        workoutSelect.appendChild(opt);
      }

      if (defaultWorkoutId && getWorkoutById(defaultWorkoutId)) {
        workoutSelect.value = defaultWorkoutId;
        return;
      }

      const d = new Date();
      const idx = d.getDay();
      let dayDefaultId = null;
      if (idx >= 1 && idx <= 5 && appData.workouts[idx - 1]) dayDefaultId = appData.workouts[idx - 1].id;
      if (dayDefaultId) workoutSelect.value = dayDefaultId;
    }

    function populateExerciseSelect(preferExerciseId) {
      exerciseSelect.innerHTML = "";
      const workout = getWorkoutById(workoutSelect.value);
      if (!workout) return;

      for (let i = 0; i < workout.exercises.length; i++) {
        const ex = workout.exercises[i];
        const opt = document.createElement("option");
        opt.value = ex.id;
        opt.textContent = ex.name;
        exerciseSelect.appendChild(opt);
      }

      if (preferExerciseId && getExerciseById(workout, preferExerciseId)) exerciseSelect.value = preferExerciseId;

      updateWorkoutMeta();
      updateExerciseMeta(true);
      saveUIState({ workoutId: workoutSelect.value, exerciseId: exerciseSelect.value });
    }

    function updateWorkoutMeta() {
      const workout = getWorkoutById(workoutSelect.value);
      warmupCard.innerHTML = "";

      const p1 = document.createElement("p");
      const s1 = document.createElement("strong");
      s1.textContent = "Échauffement :";
      p1.appendChild(s1);
      p1.appendChild(document.createTextNode(" " + (workout ? workout.warmup : "–")));

      const p2 = document.createElement("p");
      const s2 = document.createElement("strong");
      s2.textContent = "Cardio fin de séance :";
      p2.appendChild(s2);
      p2.appendChild(document.createTextNode(" " + (workout ? workout.cardio : "–")));

      warmupCard.appendChild(p1);
      warmupCard.appendChild(p2);
    }

    function buildTargetLines(target, rr, rirValue) {
      exerciseTargetInfo.innerHTML = "";

      function line(label, value) {
        const row = document.createElement("div");
        row.className = "target-line";

        const l = document.createElement("span");
        l.className = "target-label";
        l.textContent = label;

        const v = document.createElement("span");
        v.className = "target-value";
        v.textContent = value;

        row.appendChild(l);
        row.appendChild(v);
        return row;
      }

      exerciseTargetInfo.appendChild(line("Séries", String(target)));
      exerciseTargetInfo.appendChild(line("Reps", rr));
      exerciseTargetInfo.appendChild(line("RIR", rirValue));
    }

    function recomputeSetNumbers(dayLogs) {
      const byKey = {};
      for (let i = 0; i < dayLogs.length; i++) {
        const e = dayLogs[i];
        const k = e.workoutId + "|" + e.exerciseId;
        if (!byKey[k]) byKey[k] = [];
        byKey[k].push(e);
      }
      for (const k in byKey) {
        byKey[k].sort(function (a, b) {
          if (a.ts < b.ts) return -1;
          if (a.ts > b.ts) return 1;
          return 0;
        });
        for (let j = 0; j < byKey[k].length; j++) byKey[k][j].setNumber = j + 1;
      }
    }

    function getLatestEntryForExercise(workoutId, exerciseId) {
      let best = null;
      for (const dayKey in logs) {
        if (!Object.prototype.hasOwnProperty.call(logs, dayKey)) continue;
        const dayLogs = logs[dayKey];
        if (!Array.isArray(dayLogs)) continue;
        for (let i = 0; i < dayLogs.length; i++) {
          const e = dayLogs[i];
          if (e.workoutId === workoutId && e.exerciseId === exerciseId) {
            if (!best || (e.ts && best.ts && e.ts > best.ts) || (e.ts && !best.ts)) best = e;
          }
        }
      }
      return best;
    }

    function estimateE1RM(weight, reps) {
      const w = (weight || weight === 0) ? Number(weight) : null;
      const r = reps ? Number(reps) : null;
      if (w === null || !Number.isFinite(w)) return null;
      if (r === null || !Number.isFinite(r) || r < 1) return null;
      const e = w * (1 + r / 30);
      return Math.round(e * 2) / 2;
    }

    function computePRs(workoutId, exerciseId) {
      let bestW = null, bestWDay = null;
      let bestE = null, bestEDay = null;
      let bestV = null, bestVDay = null;

      for (const dayKey in logs) {
        if (!Object.prototype.hasOwnProperty.call(logs, dayKey)) continue;
        const dayLogs = logs[dayKey];
        if (!Array.isArray(dayLogs)) continue;

        for (let i = 0; i < dayLogs.length; i++) {
          const e = dayLogs[i];
          if (e.workoutId !== workoutId || e.exerciseId !== exerciseId) continue;

          const w = (e.weight || e.weight === 0) ? Number(e.weight) : null;
          const r = e.reps ? Number(e.reps) : null;

          if (w !== null && Number.isFinite(w)) {
            if (bestW === null || w > bestW) { bestW = w; bestWDay = dayKey; }
          }

          const e1 = estimateE1RM(w, r);
          if (e1 !== null) {
            if (bestE === null || e1 > bestE) { bestE = e1; bestEDay = dayKey; }
          }

          if (w !== null && r !== null && Number.isFinite(w) && Number.isFinite(r)) {
            const vol = w * r;
            if (bestV === null || vol > bestV) { bestV = Math.round(vol); bestVDay = dayKey; }
          }
        }
      }

      return { bestW, bestWDay, bestE, bestEDay, bestV, bestVDay };
    }

    function shouldAutofillFromLast(last) {
      if (!settings.autofill) return false;
      if (!last) return false;
      if (editingEntry) return false;
      const hasUserInput = (weightInput.value && weightInput.value !== "") || (repsInput.value && repsInput.value !== "");
      return !hasUserInput;
    }

    function applyAutofillFromLast(last) {
      if (!last) return false;
      let filled = false;

      if (last.weight !== undefined && last.weight !== null && weightInput.value === "") {
        weightInput.value = String(last.weight);
        filled = true;
      }
      if (last.reps !== undefined && last.reps !== null && repsInput.value === "") {
        repsInput.value = String(last.reps);
        filled = true;
      }

      autofillHint.style.display = filled ? "block" : "none";
      return filled;
    }

    function updateExerciseMeta(allowAutofill) {
      const workout = getWorkoutById(workoutSelect.value);
      const exercise = getExerciseById(workout, exerciseSelect.value);
      autofillHint.style.display = "none";

      if (!exercise) {
        exerciseRestLabel.textContent = "–";
        exerciseTargetInfo.textContent = "–";
        exerciseSetsInfo.textContent = "Séries terminées aujourd’hui : 0 / 0";
        exerciseSetsInfo.style.color = "var(--muted-soft)";
        exerciseLastInfo.textContent = "–";
        renderExerciseProgress();
        return;
      }

      exerciseRestLabel.textContent = secondsToText(exercise.restSec);

      const target = exercise.sets || 0;
      const rr = exercise.repRange || "–";
      const rir = exercise.rir || "RIR ?";
      const rirValue = String(rir).replace(/RIR\s*/i, "");
      buildTargetLines(target, rr, rirValue);

      const dayKey = getTodayKey();
      const dayLogs = Array.isArray(logs[dayKey]) ? logs[dayKey] : [];
      let done = 0;
      for (let i = 0; i < dayLogs.length; i++) {
        if (dayLogs[i].workoutId === workout.id && dayLogs[i].exerciseId === exercise.id) done++;
      }

      exerciseSetsInfo.textContent = "Séries terminées aujourd’hui : " + done + " / " + target;
      exerciseSetsInfo.style.color = (target > 0 && done >= target) ? "#22c55e" : "var(--muted-soft)";

      const last = getLatestEntryForExercise(workout.id, exercise.id);
      const prs = computePRs(workout.id, exercise.id);

      if (!last && prs.bestW === null && prs.bestE === null) {
        exerciseLastInfo.textContent = "Aucune donnée pour cet exercice.";
      } else {
        const wrap = document.createElement("div");
        wrap.className = "mini-lines";

        const l1 = document.createElement("div");
        l1.className = "mini-line";
        const k1 = document.createElement("div"); k1.className = "mini-k"; k1.textContent = "Dernière";
        const v1 = document.createElement("div"); v1.className = "mini-v";
        if (!last) v1.textContent = "—";
        else {
          const w = (last.weight || last.weight === 0) ? (last.weight + " kg") : "— kg";
          const r = last.reps ? (last.reps + " reps") : "— reps";
          const t = last.ts ? (" • " + formatHHMM(last.ts)) : "";
          v1.textContent = w + " • " + r + t;
        }
        l1.appendChild(k1); l1.appendChild(v1);

        const l2 = document.createElement("div");
        l2.className = "mini-line";
        const k2 = document.createElement("div"); k2.className = "mini-k"; k2.textContent = "Record poids";
        const v2 = document.createElement("div"); v2.className = "mini-v";
        v2.textContent = (prs.bestW === null) ? "—" : (prs.bestW + " kg • " + formatDDMM(prs.bestWDay));
        l2.appendChild(k2); l2.appendChild(v2);

        const l3 = document.createElement("div");
        l3.className = "mini-line";
        const k3 = document.createElement("div"); k3.className = "mini-k"; k3.textContent = "e1RM max";
        const v3 = document.createElement("div"); v3.className = "mini-v";
        v3.textContent = (prs.bestE === null) ? "—" : ("~" + prs.bestE + " kg • " + formatDDMM(prs.bestEDay));
        l3.appendChild(k3); l3.appendChild(v3);

        const l4 = document.createElement("div");
        l4.className = "mini-line";
        const k4 = document.createElement("div"); k4.className = "mini-k"; k4.textContent = "Record volume";
        const v4 = document.createElement("div"); v4.className = "mini-v";
        v4.textContent = (prs.bestV === null) ? "—" : (prs.bestV + " • " + formatDDMM(prs.bestVDay));
        l4.appendChild(k4); l4.appendChild(v4);

        wrap.appendChild(l1);
        wrap.appendChild(l2);
        wrap.appendChild(l3);
        wrap.appendChild(l4);

        exerciseLastInfo.innerHTML = "";
        exerciseLastInfo.appendChild(wrap);
      }

      if (allowAutofill && shouldAutofillFromLast(last)) {
        const filled = applyAutofillFromLast(last);
        if (filled) showToast("Auto-rempli depuis dernière perf", { duration: 1400 });
      }

      renderExerciseProgress();
      updateHistorySummary();
    }

    function computeDayStats(dayKey) {
      const dayLogs = Array.isArray(logs[dayKey]) ? logs[dayKey] : [];
      let tonnage = 0;
      let hasTonnage = false;
      const exSet = {};

      for (let i = 0; i < dayLogs.length; i++) {
        const e = dayLogs[i];
        exSet[(e.workoutId || "?") + "|" + (e.exerciseId || "?")] = true;
        if ((e.weight || e.weight === 0) && e.reps) {
          tonnage += Number(e.weight) * Number(e.reps);
          hasTonnage = true;
        }
      }

      const exCount = Object.keys(exSet).length;
      return { sets: dayLogs.length, exCount: exCount, tonnage: hasTonnage ? Math.round(tonnage) : null };
    }

    function updateHistorySummary() {
      const dk = viewDayKey || getTodayKey();
      const s = computeDayStats(dk);

      if (s.sets === 0) {
        historySummary.textContent = "Séries enregistrées (stockées sur ce téléphone)";
        return;
      }

      let label = (dk === getTodayKey()) ? "Aujourd’hui" : ("Jour " + formatDDMM(dk));
      let txt = label + " : " + s.sets + " séries • " + s.exCount + " exercice" + (s.exCount > 1 ? "s" : "");
      if (s.tonnage !== null) txt += " • Volume ~ " + s.tonnage + " kg";
      historySummary.textContent = txt;
    }

    function renderLogsForDay(dayKey) {
      const dayLogs = Array.isArray(logs[dayKey]) ? logs[dayKey] : [];
      logList.innerHTML = "";
      updateHistorySummary();

      if (dayLogs.length === 0) {
        const empty = document.createElement("div");
        empty.className = "card-subtitle";
        empty.textContent = "Aucune série enregistrée pour ce jour.";
        logList.appendChild(empty);
        return;
      }

      const frag = document.createDocumentFragment();
      for (let i = dayLogs.length - 1; i >= 0; i--) {
        const entry = dayLogs[i];
        const index = i;

        const item = document.createElement("div");
        item.className = "log-item";

        const main = document.createElement("div");
        main.className = "log-main";

        const title = document.createElement("div");
        title.className = "log-title";
        title.textContent = entry.workoutName + " – " + entry.exerciseName;

        const meta = document.createElement("div");
        meta.className = "log-meta";
        const weightText = (entry.weight || entry.weight === 0) ? entry.weight + " kg" : "Poids ?";
        const repsText = entry.reps ? entry.reps + " reps" : "Reps ?";
        const hhmm = formatHHMM(entry.ts);
        meta.textContent = "Série " + (entry.setNumber || "?") + " • " + weightText + " • " + repsText + (hhmm ? " • " + hhmm : "");

        main.appendChild(title);
        main.appendChild(meta);

        const actions = document.createElement("div");
        actions.className = "log-actions";

        const tag = document.createElement("div");
        tag.className = "log-tag";
        tag.textContent = formatTime(entry.restSec || 0);

        const btnRow = document.createElement("div");
        btnRow.className = "log-btns";

        const editBtn = document.createElement("button");
        editBtn.type = "button";
        editBtn.className = "log-edit-btn";
        editBtn.textContent = "Modifier";
        editBtn.setAttribute("data-index", String(index));

        const deleteBtn = document.createElement("button");
        deleteBtn.type = "button";
        deleteBtn.className = "log-delete-btn";
        deleteBtn.setAttribute("data-index", String(index));

        const isPending = pendingDelete && pendingDelete.dayKey === dayKey && pendingDelete.index === index && Date.now() < pendingDelete.untilMs;
        if (isPending) { deleteBtn.textContent = "Confirmer"; deleteBtn.classList.add("confirm"); }
        else { deleteBtn.textContent = "Supprimer"; deleteBtn.classList.remove("confirm"); }

        btnRow.appendChild(editBtn);
        btnRow.appendChild(deleteBtn);

        actions.appendChild(tag);
        actions.appendChild(btnRow);

        item.appendChild(main);
        item.appendChild(actions);

        frag.appendChild(item);
      }

      logList.appendChild(frag);
    }

    function requestDeleteConfirm(dayKey, index) {
      pendingDelete = { dayKey: dayKey, index: index, untilMs: Date.now() + 4000 };
      renderLogsForDay(dayKey);
      showToast("Retape SUPPRIMER pour confirmer", { duration: 1800 });
    }

    function deleteLogEntry(dayKey, index) {
      const dayLogs = Array.isArray(logs[dayKey]) ? logs[dayKey] : [];
      const entry = dayLogs[index];
      if (!entry) return;

      const removed = dayLogs.splice(index, 1)[0];

      if (editingEntry && editingEntry.dayKey === dayKey) {
        if (editingEntry.index === index) exitEditMode();
        else if (editingEntry.index > index) editingEntry.index -= 1;
      }

      if (dayLogs.length === 0) delete logs[dayKey];
      else { recomputeSetNumbers(dayLogs); logs[dayKey] = dayLogs; }

      saveLogs();
      pendingDelete = null;
      renderLogsForDay(dayKey);
      updateExerciseMeta(false);

      vibrate([20]);

      showToast("Série supprimée", {
        duration: 5200,
        actionLabel: "Annuler",
        onAction: function () {
          const arr = Array.isArray(logs[dayKey]) ? logs[dayKey] : [];
          arr.splice(index, 0, removed);
          recomputeSetNumbers(arr);
          logs[dayKey] = arr;
          saveLogs();
          renderLogsForDay(dayKey);
          updateExerciseMeta(false);
          showToast("Suppression annulée", { duration: 1600 });
          vibrate([15, 30, 15]);
        }
      });
    }

    function showTimerOverlay() {
      timerOverlay.classList.add("show");
      timerOverlay.setAttribute("aria-hidden", "false");
      document.body.style.overflow = "hidden";
    }
    function hideTimerOverlay() {
      timerOverlay.classList.remove("show");
      timerOverlay.setAttribute("aria-hidden", "true");
      document.body.style.overflow = "";
    }

    function updateTimerUI() {
      timerDisplay.textContent = formatTime(timerRemaining);
      if (timerRemaining > 0 && !timerPaused) timerLabel.textContent = "Repos en cours…";
      else if (timerRemaining > 0 && timerPaused) timerLabel.textContent = "Pause";
      else timerLabel.textContent = "Repos terminé ou en attente";
      pauseTimerBtn.textContent = timerPaused ? "Reprendre" : "Pause";
    }

    function releaseWakeLock() {
      if (wakeLockSentinel) {
        try { wakeLockSentinel.release(); } catch (_) {}
        wakeLockSentinel = null;
      }
    }

    async function requestWakeLock() {
      if (!settings.wakelock) return;
      if (!("wakeLock" in navigator)) return;
      try {
        if (wakeLockSentinel) return;
        wakeLockSentinel = await navigator.wakeLock.request("screen");
        wakeLockSentinel.addEventListener("release", function () { wakeLockSentinel = null; });
      } catch (_) {}
    }

    function stopTimerInternal() {
      if (timerId) { clearInterval(timerId); timerId = null; }
      timerDeadlineMs = 0;
      lastTimerRemaining = null;
      timerPaused = false;
      releaseWakeLock();
    }

    function persistRunningTimer() {
      if (!timerDeadlineMs || timerRemaining <= 0 || timerPaused) return;
      saveTimerState({
        status: "running",
        deadlineMs: timerDeadlineMs,
        restSec: lastRestSec,
        updatedAt: Date.now()
      });
    }

    function persistPausedTimer() {
      if (timerRemaining <= 0) return;
      saveTimerState({
        status: "paused",
        remainingSec: timerRemaining,
        restSec: lastRestSec,
        updatedAt: Date.now()
      });
    }

    function startTimer(seconds, opts) {
      stopTimerInternal();

      const sec = Math.max(0, Number(seconds) || 0);
      lastRestSec = sec;

      timerDeadlineMs = Date.now() + sec * 1000;
      timerRemaining = sec;
      lastTimerRemaining = sec;
      timerPaused = false;
      updateTimerUI();

      requestWakeLock();

      if (!(opts && opts.silentOpen)) showTimerOverlay();
      persistRunningTimer();

      if (sec <= 0) return;

      timerId = setInterval(function () {
        if (timerPaused) return;

        const diffMs = timerDeadlineMs - Date.now();
        const newRemaining = Math.max(0, Math.ceil(diffMs / 1000));

        if (newRemaining !== timerRemaining) {
          lastTimerRemaining = timerRemaining;
          timerRemaining = newRemaining;
          updateTimerUI();

          persistRunningTimer();

          if (lastTimerRemaining !== null && lastTimerRemaining > 10 && timerRemaining <= 10 && timerRemaining > 0) {
            beep(880, 120, 0.06);
          }
        }

        if (timerRemaining <= 0) {
          stopTimerInternal();
          timerRemaining = 0;
          updateTimerUI();
          timerLabel.textContent = "Repos terminé ✔";
          vibrate([35, 60, 35]);
          beep(988, 160, 0.07);
          setTimeout(function(){ beep(784, 140, 0.06); }, 180);
          showToast("Repos terminé", { duration: 2200 });
          notifyRestFinished();
          clearTimerState();

          setTimeout(function(){
            hideTimerOverlay();
          }, 1400);
        }
      }, 250);
    }

    function pauseOrResumeTimer() {
      if (!timerId && timerRemaining > 0) {
        // si on a un restant mais pas d'interval (rare), on relance
        startTimer(timerRemaining);
        return;
      }

      if (timerRemaining <= 0) return;

      if (!timerPaused) {
        // pause
        timerPaused = true;
        stopTimerInternal(); // stop interval + wakelock
        timerPaused = true;  // re-mark
        updateTimerUI();
        persistPausedTimer();
        showToast("Pause", { duration: 900 });
        vibrate([10]);
        return;
      }

      // reprendre
      timerPaused = false;
      timerDeadlineMs = Date.now() + timerRemaining * 1000;
      updateTimerUI();
      requestWakeLock();
      persistRunningTimer();

      timerId = setInterval(function () {
        if (timerPaused) return;

        const diffMs = timerDeadlineMs - Date.now();
        const newRemaining = Math.max(0, Math.ceil(diffMs / 1000));

        if (newRemaining !== timerRemaining) {
          lastTimerRemaining = timerRemaining;
          timerRemaining = newRemaining;
          updateTimerUI();

          persistRunningTimer();

          if (lastTimerRemaining !== null && lastTimerRemaining > 10 && timerRemaining <= 10 && timerRemaining > 0) {
            beep(880, 120, 0.06);
          }
        }

        if (timerRemaining <= 0) {
          stopTimerInternal();
          timerRemaining = 0;
          updateTimerUI();
          timerLabel.textContent = "Repos terminé ✔";
          vibrate([35, 60, 35]);
          beep(988, 160, 0.07);
          setTimeout(function(){ beep(784, 140, 0.06); }, 180);
          showToast("Repos terminé", { duration: 2200 });
          notifyRestFinished();
          clearTimerState();

          setTimeout(function(){ hideTimerOverlay(); }, 1400);
        }
      }, 250);

      showToast("Repris", { duration: 900 });
      vibrate([10]);
    }

    function resetTimer() {
      stopTimerInternal();
      timerRemaining = 0;
      updateTimerUI();
      clearTimerState();
    }

    function handleRestartTimer() {
      if (!lastRestSec || lastRestSec <= 0) {
        // fallback sur repos de l'exercice sélectionné
        const workout = getWorkoutById(workoutSelect.value);
        const exercise = getExerciseById(workout, exerciseSelect.value);
        if (exercise) lastRestSec = exercise.restSec || 0;
      }
      startTimer(lastRestSec);
      showToast("Chrono relancé", { duration: 1200 });
      vibrate([10]);
    }

    function enterEditMode(dayKey, index, entry) {
      editingEntry = { dayKey: dayKey, index: index };
      workoutSelect.value = entry.workoutId;
      populateExerciseSelect(entry.exerciseId);
      updateExerciseMeta(false);

      weightInput.value = (entry.weight !== undefined && entry.weight !== null) ? String(entry.weight) : "";
      repsInput.value = (entry.reps !== undefined && entry.reps !== null) ? String(entry.reps) : "";

      logSetBtn.textContent = editBtnText;
      cancelEditBtn.style.display = "inline-flex";
      editIndicator.style.display = "block";
      showToast("Mode édition", { duration: 1200 });
      vibrate([15]);
    }

    function exitEditMode() {
      editingEntry = null;
      logSetBtn.textContent = defaultBtnText;
      cancelEditBtn.style.display = "none";
      editIndicator.style.display = "none";
    }

    function parseNumberOrNull(inputEl) {
      const v = inputEl.value;
      if (v === "" || v === null || v === undefined) return null;
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    }

    function handleLogSet() {
      const workout = getWorkoutById(workoutSelect.value);
      const exercise = getExerciseById(workout, exerciseSelect.value);
      if (!workout || !exercise) return;

      const weight = parseNumberOrNull(weightInput);
      const reps = parseNumberOrNull(repsInput);

      if (weight !== null && weight < 0) { showToast("Poids invalide", { duration: 1800 }); return; }
      if (reps !== null && reps < 1) { showToast("Reps invalides", { duration: 1800 }); return; }
      if (weight === null && reps === null) { showToast("Renseigne au moins poids ou reps", { duration: 2200 }); return; }

      if (editingEntry) {
        const dayKeyEdit = editingEntry.dayKey;
        const indexEdit = editingEntry.index;
        const dayLogsEdit = Array.isArray(logs[dayKeyEdit]) ? logs[dayKeyEdit] : [];
        const entryEdit = dayLogsEdit[indexEdit];
        if (!entryEdit) { exitEditMode(); return; }

        entryEdit.workoutId = workout.id;
        entryEdit.workoutName = workout.name;
        entryEdit.exerciseId = exercise.id;
        entryEdit.exerciseName = exercise.name;
        entryEdit.weight = weight;
        entryEdit.reps = reps;
        entryEdit.restSec = exercise.restSec;

        recomputeSetNumbers(dayLogsEdit);
        logs[dayKeyEdit] = dayLogsEdit;

        saveLogs();
        renderLogsForDay(dayKeyEdit);
        updateExerciseMeta(false);
        startTimer(exercise.restSec);
        exitEditMode();

        vibrate([20]);
        showToast("Série mise à jour", { duration: 1600 });
        return;
      }

      const dayKey = getTodayKey();
      if (!Array.isArray(logs[dayKey])) logs[dayKey] = [];
      const dayLogs = logs[dayKey];

      let existingCount = 0;
      for (let i = 0; i < dayLogs.length; i++) {
        if (dayLogs[i].workoutId === workout.id && dayLogs[i].exerciseId === exercise.id) existingCount++;
      }
      const setNumber = existingCount + 1;

      const entry = {
        ts: new Date().toISOString(),
        workoutId: workout.id,
        workoutName: workout.name,
        exerciseId: exercise.id,
        exerciseName: exercise.name,
        setNumber: setNumber,
        weight: weight,
        reps: reps,
        restSec: exercise.restSec
      };

      dayLogs.push(entry);
      recomputeSetNumbers(dayLogs);
      logs[dayKey] = dayLogs;

      saveLogs();

      if (viewDayKey !== dayKey) {
        showToast("Ajouté à aujourd’hui (pas au jour affiché)", {
          duration: 3800,
          actionLabel: "Voir",
          onAction: function () { setViewDayKey(dayKey); }
        });
      } else {
        showToast("Série enregistrée", { duration: 1400 });
      }

      renderLogsForDay(viewDayKey);
      startTimer(exercise.restSec);

      const targetSets = exercise.sets || 0;
      let advanced = false;

      if (settings.autonext && targetSets > 0 && setNumber >= targetSets) {
        let idxEx = -1;
        for (let j = 0; j < workout.exercises.length; j++) {
          if (workout.exercises[j].id === exercise.id) { idxEx = j; break; }
        }
        if (idxEx >= 0 && idxEx < workout.exercises.length - 1) {
          const nextEx = workout.exercises[idxEx + 1];
          exerciseSelect.value = nextEx.id;
          saveUIState({ workoutId: workoutSelect.value, exerciseId: exerciseSelect.value });
          advanced = true;
        }
      }

      if (advanced) { weightInput.value = ""; repsInput.value = ""; showToast("Exercice suivant", { duration: 1500 }); }
      else { repsInput.value = ""; showToast("Repos lancé", { duration: 1200 }); }

      vibrate([15]);
      updateExerciseMeta(false);
      renderExerciseProgress();
    }

    function resetClearConfirmUI() {
      clearConfirm = false;
      if (clearConfirmTimeout) { clearTimeout(clearConfirmTimeout); clearConfirmTimeout = null; }
      clearHistoryBtn.textContent = "Supprimer tout l'historique";
      clearHistoryBtn.classList.remove("btn-danger-active");
    }

    function handleClearHistory() {
      if (!clearConfirm) {
        clearConfirm = true;
        clearHistoryBtn.textContent = "Confirmer la suppression";
        clearHistoryBtn.classList.add("btn-danger-active");
        if (clearConfirmTimeout) clearTimeout(clearConfirmTimeout);
        clearConfirmTimeout = setTimeout(resetClearConfirmUI, 5000);
        showToast("2e clic pour ouvrir la confirmation", { duration: 2000 });
        return;
      }

      const snapshot = JSON.stringify(logs);
      openModal({
        title: "SUPPRIMER TOUT ?",
        body: "Tu vas supprimer TOUT l’historique (tous les jours). Action définitive, mais tu peux annuler juste après.",
        confirmText: "Supprimer",
        cancelText: "Annuler",
        onConfirm: function () {
          resetClearConfirmUI();

          logs = {};
          saveLogs();
          pendingDelete = null;
          renderLogsForDay(viewDayKey);
          updateExerciseMeta(false);
          exitEditMode();
          renderExerciseProgress();

          vibrate([35]);

          showToast("Historique supprimé", {
            duration: 7000,
            actionLabel: "Annuler",
            onAction: function () {
              logs = safeJsonParse(snapshot, {});
              if (!logs || typeof logs !== "object") logs = {};
              saveLogs();
              renderLogsForDay(viewDayKey);
              updateExerciseMeta(false);
              renderExerciseProgress();
              showToast("Suppression annulée", { duration: 1700 });
              vibrate([15, 40, 15]);
            }
          });
        }
      });
    }

    function renderExerciseProgress() {
      const workout = getWorkoutById(workoutSelect.value);
      const exercise = getExerciseById(workout, exerciseSelect.value);

      progressChart.innerHTML = "";

      if (!workout || !exercise) {
        progressChart.className = "progress-chart-placeholder";
        progressChart.textContent = "Sélectionne un exercice.";
        progressSummary.textContent = "Sélectionne un exercice pour voir l'évolution.";
        return;
      }

      const allPoints = [];
      let record = null;
      let recordE1 = null;

      for (const key in logs) {
        if (!Object.prototype.hasOwnProperty.call(logs, key)) continue;
        const dayLogs = logs[key];
        if (!Array.isArray(dayLogs)) continue;

        let bestWeight = null;
        for (let i = 0; i < dayLogs.length; i++) {
          const e = dayLogs[i];
          if (e.workoutId === workout.id && e.exerciseId === exercise.id) {
            const w = (e.weight || e.weight === 0) ? Number(e.weight) : null;
            if (w !== null && (bestWeight === null || w > bestWeight)) bestWeight = w;

            const e1 = estimateE1RM(e.weight, e.reps);
            if (e1 !== null && (recordE1 === null || e1 > recordE1)) recordE1 = e1;
          }
        }
        if (bestWeight !== null) {
          allPoints.push({ dayKey: key, bestWeight: bestWeight });
          if (record === null || bestWeight > record) record = bestWeight;
        }
      }

      if (allPoints.length === 0) {
        progressChart.className = "progress-chart-placeholder";
        progressChart.textContent = "Pas encore de données (avec un poids) pour cet exercice.";
        progressSummary.textContent = "Enregistre quelques séries avec un poids pour voir la progression.";
        return;
      }

      allPoints.sort(function (a, b) {
        if (a.dayKey < b.dayKey) return -1;
        if (a.dayKey > b.dayKey) return 1;
        return 0;
      });

      const last = allPoints[allPoints.length - 1];
      const prev = allPoints.length > 1 ? allPoints[allPoints.length - 2] : null;
      const delta = prev ? (last.bestWeight - prev.bestWeight) : null;

      let summary = "Dernière séance : " + last.bestWeight + " kg";
      summary += " • Séances : " + allPoints.length;
      if (record !== null) summary += " • Record : " + record + " kg";
      if (recordE1 !== null) summary += " • e1RM max ~ " + recordE1 + " kg";
      if (delta !== null) summary += " • Δ : " + (delta >= 0 ? "+" : "") + delta + " kg";
      progressSummary.textContent = summary;

      // ✅ plus grand
      const width = 360, height = 220, margin = 30;

      const weights = allPoints.map(function (p) { return p.bestWeight || 0; });
      const minW = Math.min.apply(null, weights);
      const maxW = Math.max.apply(null, weights);
      const wRange = (maxW - minW) || 1;

      const xStep = allPoints.length > 1 ? (width - 2 * margin) / (allPoints.length - 1) : 0;

      const points = allPoints.map(function (p, i) {
        const x = margin + i * xStep;
        const norm = (p.bestWeight - minW) / wRange;
        const y = height - margin - norm * (height - 2 * margin);
        return { x: x, y: y, dayKey: p.dayKey, bestWeight: p.bestWeight };
      });

      const polylinePoints = points.map(function (p) { return p.x + "," + p.y; }).join(" ");
      const stroke = "#fb4b5a";

      let svg = '<svg viewBox="0 0 ' + width + ' ' + height + '">';
      svg +=
        '<line x1="' + margin + '" y1="' + (height - margin) + '" x2="' + (width - margin) + '" y2="' + (height - margin) + '" stroke="rgba(148,163,184,0.45)" stroke-width="1" />' +
        '<line x1="' + margin + '" y1="' + margin + '" x2="' + margin + '" y2="' + (height - margin) + '" stroke="rgba(148,163,184,0.45)" stroke-width="1" />';

      if (points.length > 1) svg += '<polyline points="' + polylinePoints + '" fill="none" stroke="' + stroke + '" stroke-width="3.0" />';

      for (let i = 0; i < points.length; i++) {
        const p = points[i];
        const parts = p.dayKey.split("-");
        const dateShort = parts[2] + "/" + parts[1];
        svg += '<circle cx="' + p.x + '" cy="' + p.y + '" r="3.6" fill="' + stroke + '" />';
        svg += '<text x="' + p.x + '" y="' + (height - margin + 16) + '" font-size="9.5" text-anchor="middle" fill="rgba(148,163,184,0.95)">' + dateShort + '</text>';
      }

      svg +=
        '<text x="' + (margin - 8) + '" y="' + (height - margin) + '" font-size="9.5" text-anchor="end" fill="rgba(148,163,184,0.95)">' + minW + ' kg</text>' +
        '<text x="' + (margin - 8) + '" y="' + (margin + 6) + '" font-size="9.5" text-anchor="end" fill="rgba(148,163,184,0.95)">' + maxW + ' kg</text>';

      svg += '</svg>';
      progressChart.className = "";
      progressChart.innerHTML = svg;
    }

    function setViewDayKey(dayKey) {
      const t = getTodayKey();
      viewDayKey = (dayKey && typeof dayKey === "string") ? dayKey : t;
      historyDateInput.value = viewDayKey;

      pendingDelete = null;
      if (editingEntry) {
        exitEditMode();
        showToast("Édition annulée (changement de jour)", { duration: 1700 });
      }

      if (Array.isArray(logs[viewDayKey])) {
        recomputeSetNumbers(logs[viewDayKey]);
        saveLogs();
      }

      renderLogsForDay(viewDayKey);

      if (viewDayKey !== t) {
        showToast("Tu consultes le " + formatDDMM(viewDayKey), {
          duration: 2600,
          actionLabel: "Aujourd’hui",
          onAction: function () { setViewDayKey(t); }
        });
      }
    }

    function applySettingsToUI() {
      setVibrate.checked = !!settings.vibrate;
      setSound.checked = !!settings.sound;
      setNotif.checked = !!settings.notifications;
      setAutofill.checked = !!settings.autofill;
      setAutonext.checked = !!settings.autonext;
      setWakelock.checked = !!settings.wakelock;
    }

    function initSettingsHandlers() {
      setVibrate.addEventListener("change", function () {
        settings.vibrate = !!setVibrate.checked;
        saveSettings();
        showToast(settings.vibrate ? "Vibration ON" : "Vibration OFF", { duration: 1200 });
        vibrate([10]);
      });

      setSound.addEventListener("change", function () {
        settings.sound = !!setSound.checked;
        saveSettings();
        if (settings.sound) {
          ensureAudio();
          beep(880, 120, 0.06);
          showToast("Son ON", { duration: 1200 });
        } else {
          showToast("Son OFF", { duration: 1200 });
        }
      });

      setNotif.addEventListener("change", function () {
        const want = !!setNotif.checked;
        if (!("Notification" in window)) {
          settings.notifications = false;
          setNotif.checked = false;
          saveSettings();
          showToast("Notifications non supportées", { duration: 2200 });
          return;
        }

        if (want && Notification.permission === "default") {
          Notification.requestPermission().then(function (perm) {
            if (perm === "granted") {
              settings.notifications = true;
              saveSettings();
              showToast("Notifications ON", { duration: 1500 });
              try { new Notification("OK ✔", { body: "Tu recevras l’alerte repos terminé." }); } catch (_) {}
            } else {
              settings.notifications = false;
              setNotif.checked = false;
              saveSettings();
              showToast("Notifications refusées", { duration: 1800 });
            }
          }).catch(function () {
            settings.notifications = false;
            setNotif.checked = false;
            saveSettings();
            showToast("Erreur permission notif", { duration: 1800 });
          });
          return;
        }

        if (want && Notification.permission !== "granted") {
          settings.notifications = false;
          setNotif.checked = false;
          saveSettings();
          showToast("Active d’abord la permission notif", { duration: 2000 });
          return;
        }

        settings.notifications = want;
        saveSettings();
        showToast(settings.notifications ? "Notifications ON" : "Notifications OFF", { duration: 1200 });
      });

      setAutofill.addEventListener("change", function () {
        settings.autofill = !!setAutofill.checked;
        saveSettings();
        showToast(settings.autofill ? "Auto-remplissage ON" : "Auto-remplissage OFF", { duration: 1400 });
      });

      setAutonext.addEventListener("change", function () {
        settings.autonext = !!setAutonext.checked;
        saveSettings();
        showToast(settings.autonext ? "Auto-suivant ON" : "Auto-suivant OFF", { duration: 1400 });
      });

      setWakelock.addEventListener("change", function () {
        settings.wakelock = !!setWakelock.checked;
        saveSettings();
        showToast(settings.wakelock ? "Écran allumé ON" : "Écran allumé OFF", { duration: 1500 });

        if (settings.wakelock) {
          if (!("wakeLock" in navigator)) showToast("Wake lock non supporté", { duration: 2200 });
          else if (timerId) requestWakeLock();
        } else {
          releaseWakeLock();
        }
      });

      document.addEventListener("visibilitychange", function () {
        if (document.visibilityState === "visible" && timerId && settings.wakelock) requestWakeLock();
      });
    }

    function restoreTimerIfAny() {
      const t = loadTimerState();
      if (!t || !t.status) return;

      if (t.restSec && Number.isFinite(Number(t.restSec))) lastRestSec = Number(t.restSec);

      if (t.status === "paused" && t.remainingSec && Number(t.remainingSec) > 0) {
        timerRemaining = Math.max(0, Math.floor(Number(t.remainingSec)));
        timerPaused = true;
        updateTimerUI();
        showTimerOverlay();
        showToast("Chrono en pause (restauré)", { duration: 1400 });
        return;
      }

      if (t.status === "running" && t.deadlineMs) {
        const remain = Math.max(0, Math.ceil((Number(t.deadlineMs) - Date.now()) / 1000));
        if (remain <= 0) {
          clearTimerState();
          return;
        }
        timerRemaining = remain;
        startTimer(remain, { silentOpen: true });
        showTimerOverlay();
        showToast("Chrono restauré", { duration: 1200 });
      }
    }

    function init() {
      loadSettings();
      applySettingsToUI();
      initSettingsHandlers();

      loadLogs();
      initTodayUI();

      const ui = loadUIState();
      populateWorkoutSelect(ui && ui.workoutId ? ui.workoutId : null);
      populateExerciseSelect(ui && ui.exerciseId ? ui.exerciseId : null);

      const today = getTodayKey();
      setViewDayKey(today);

      renderExerciseProgress();

      // restore timer (continuité si tu quittes/reviens)
      restoreTimerIfAny();

      workoutSelect.addEventListener("change", function () {
        pendingDelete = null;
        populateExerciseSelect(null);
      });

      exerciseSelect.addEventListener("change", function () {
        pendingDelete = null;
        updateExerciseMeta(true);
        saveUIState({ workoutId: workoutSelect.value, exerciseId: exerciseSelect.value });
      });

      logSetBtn.addEventListener("click", handleLogSet);
      clearHistoryBtn.addEventListener("click", handleClearHistory);

      cancelEditBtn.addEventListener("click", function () {
        exitEditMode();
        showToast("Édition annulée", { duration: 1200 });
        vibrate([10]);
      });

      historyDateInput.addEventListener("change", function () {
        const v = historyDateInput.value;
        if (!v) { setViewDayKey(getTodayKey()); return; }
        setViewDayKey(v);
      });
      historyTodayBtn.addEventListener("click", function () {
        setViewDayKey(getTodayKey());
      });

      // UX clavier mobile
      weightInput.addEventListener("keydown", function (e) {
        if (e.key === "Enter") { e.preventDefault(); repsInput.focus(); }
      });
      repsInput.addEventListener("keydown", function (e) {
        if (e.key === "Enter") { e.preventDefault(); handleLogSet(); }
      });

      // Quick buttons
      document.addEventListener("click", function (e) {
        const btn = e.target;
        if (!btn || !btn.getAttribute) return;
        const q = btn.getAttribute("data-q");
        if (!q) return;

        e.preventDefault();

        const parts = q.split(":");
        if (parts.length !== 2) return;
        const kind = parts[0];
        const op = parts[1];

        function bump(el, delta, step) {
          const cur = parseNumberOrNull(el);
          const base = (cur === null) ? 0 : cur;
          const next = base + delta;
          const fixed = (step === 0.5) ? (Math.round(next * 2) / 2) : Math.round(next);
          el.value = String(Math.max(0, fixed));
        }

        if (kind === "w") {
          if (op === "clear") { weightInput.value = ""; showToast("Poids reset", { duration: 900 }); return; }
          if (op === "+2.5") bump(weightInput, 2.5, 0.5);
          if (op === "-2.5") bump(weightInput, -2.5, 0.5);
          if (op === "+5") bump(weightInput, 5, 0.5);
          showToast("Poids ajusté", { duration: 900 });
          return;
        }

        if (kind === "r") {
          if (op === "clear") { repsInput.value = ""; showToast("Reps reset", { duration: 900 }); return; }
          if (op === "+1") bump(repsInput, 1, 1);
          if (op === "-1") bump(repsInput, -1, 1);
          if (op === "+2") bump(repsInput, 2, 1);
          showToast("Reps ajustées", { duration: 900 });
          return;
        }
      });

      // Historique list actions
      logList.addEventListener("click", function (e) {
        const btn = e.target;
        const dayKeyNow = viewDayKey || getTodayKey();
        if (!btn || !btn.classList) return;

        if (btn.classList.contains("log-edit-btn")) {
          const indexEdit = Number(btn.getAttribute("data-index"));
          const dayLogsEdit = Array.isArray(logs[dayKeyNow]) ? logs[dayKeyNow] : [];
          const entryEdit = dayLogsEdit[indexEdit];
          if (!entryEdit) return;
          pendingDelete = null;
          enterEditMode(dayKeyNow, indexEdit, entryEdit);
          return;
        }

        if (btn.classList.contains("log-delete-btn")) {
          const indexDelete = Number(btn.getAttribute("data-index"));
          const isPending = pendingDelete && pendingDelete.dayKey === dayKeyNow && pendingDelete.index === indexDelete && Date.now() < pendingDelete.untilMs;
          if (!isPending) { requestDeleteConfirm(dayKeyNow, indexDelete); return; }
          deleteLogEntry(dayKeyNow, indexDelete);
          return;
        }
      });

      // Timer overlay controls
      timerCloseBtn.addEventListener("click", function(){
        // On ferme l'overlay, mais le chrono continue (si running)
        hideTimerOverlay();
        showToast("Chrono en arrière-plan", { duration: 1400 });
      });
      pauseTimerBtn.addEventListener("click", pauseOrResumeTimer);
      restartTimerBtn.addEventListener("click", handleRestartTimer);
      resetTimerBtn.addEventListener("click", function(){
        resetTimer();
        hideTimerOverlay();
        showToast("Chrono reset", { duration: 1200 });
        vibrate([10]);
      });

      // Persister si l’onglet se ferme / change
      window.addEventListener("beforeunload", function(){
        if (timerPaused && timerRemaining > 0) persistPausedTimer();
        else if (!timerPaused && timerRemaining > 0 && timerDeadlineMs) persistRunningTimer();
      });
      document.addEventListener("visibilitychange", function(){
        if (document.visibilityState === "hidden") {
          if (timerPaused && timerRemaining > 0) persistPausedTimer();
          else if (!timerPaused && timerRemaining > 0 && timerDeadlineMs) persistRunningTimer();
        }
      });
    }

    document.addEventListener("DOMContentLoaded", init);
  })();
  </script>
</body>
</html>
